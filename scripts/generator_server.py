#!/usr/bin/env python

import rospy
from basic_grasping_algorithm.srv import GenerateGrasp, GenerateGraspResponse
from grasp_generator import generate_grasp
import pcl
import numpy as np
from sensor_msgs.msg import PointCloud2
import ros_numpy
from tf2_sensor_msgs.tf2_sensor_msgs import do_transform_cloud
import tf2_ros


def ros_pointcloud2_to_pcl(ros_msg):
    """
        Function that transforms a ROS PointCloud2 msg into a PCL PointCloud object

        @param ros_msg: ROS PointCloud2 msg to transform

        @return: PCL PointCloud object equivalent to the input ROS msg
    """
    # Use the ros_numpy package to create a numpy array out of the ROS msg
    numpified = ros_numpy.numpify(ros_msg)
    # Get the number of points
    number_points = numpified.shape[0]
    # Initialize and fill in a numpy array (not a structured one as returned by ros_numpy)
    points = np.zeros((number_points, 3), dtype=np.float32)
    points[:, 0] = np.resize(numpified["x"], number_points)
    points[:, 1] = np.resize(numpified["y"], number_points)
    points[:, 2] = np.resize(numpified["z"], number_points)
    # Initialize the PCL PointCloud from the numpy array
    pcl_pc = pcl.PointCloud(points)
    return pcl_pc


def np_array_to_ros_pointcloud2(numpy_array, frame_id="world"):
    """
        Function that takes as an input a numpy array that represents a pointcloud and outputs its equivalent ROS
        PointCloud2 msg. This function is quite convenient for displaying in RViz the different steps of the grasping
        algorithm.
    """
    # Get the number of points
    number_points = numpy_array.shape[0]
    # Create the numpy structure that contains the coordinates and colour of each point
    data = np.zeros(number_points, dtype=[('x', np.float32), ('y', np.float32), ('z', np.float32), ('rgb', np.float32)])
    # Fill in the values for each coordinate
    data['x'] = numpy_array[:, 0]
    data['y'] = numpy_array[:, 1]
    data['z'] = numpy_array[:, 2]
    # Set the same colour for all the points. The colour can be changed and even set as a parameter of this function
    data['rgb'] = np.ones(number_points) * 0.85
    # Create the PointCloud2 msg
    ros_msg = ros_numpy.msgify(PointCloud2, data)
    # Make sure it has a reference frame
    ros_msg.header.frame_id = frame_id
    return ros_msg


# Function that is going to be linked to the service server
def generate_grasp_callback(request):
    """
        Function to be run everytime the service is called. From the input request, it tries to generate a grasp pose
        and returns it as the response of the service

        @param request: Input of the service, with a single field named "input"

        @return: The service response, which contains two fields, "outcome" (must be an integer) and "returned_object"
    """
    # Access to the msg stored in request
    input_pointcloud = request.input
    # Get the transform between the input pointcloud and the reference frame "world"
    transform = tf_buffer.lookup_transform("world", input_pointcloud.header.frame_id, input_pointcloud.header.stamp,
                                           rospy.Duration(0))
    # Make sure the coordinates of the point cloud are expressed in the world reference and not in the sensor's frame
    transformed_pc = do_transform_cloud(input_pointcloud, transform)
    # Make the transformed message into a PCL PointCloud object
    pcl_pc = ros_pointcloud2_to_pcl(transformed_pc)
    # Generate the grasp
    generated_grasp = generate_grasp(pcl_pc)
    # Initialize the response of the service
    response = GenerateGraspResponse()
    # Fill in the service response.
    # If the generated PoseStaped doesn't have any frame_id (i.e. it is empty), it means that not grasp has been found
    if not generated_grasp.header.frame_id:
        value = 1
    # Otherwise, a grasp is found and will be returned
    else:
        value = 0
    response.outcome = value
    # Set the returned_object field of the response by either an empty PoseStamped or the one generated by the algorithm
    response.returned_object = generated_grasp
    # Return the response
    return response

if __name__ == '__main__':
    # Initialise the node with a specific name (please change it to match your service)
    rospy.init_node('basic_grasping_server')
    # Set a tf2 buffer and transform listener
    tf_buffer = tf2_ros.Buffer()
    tf_listener = tf2_ros.TransformListener(tf_buffer)
    # Set the service up
    service = rospy.Service("basic_grasping_service", GenerateGrasp, generate_grasp_callback)
    rospy.spin()
